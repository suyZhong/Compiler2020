# Lab5 实验报告-阶段一

小组组长 蒲明昱 PB18111733 
小组成员 钟溯飏 PB18111764

## 实验要求

阅读LoopSearch.cpp，了解如何找到代码中的循环；阅读提供的参考资料及提供的代码，了解SSA，以及如何使用支配边界等条件减少phi函数冗余。

## 思考题
### LoopSearch
1. 循环的入口如何确定？循环的入口的数量可能超过1嘛？
   - 使用`find_loop_base()`确定，逻辑为：对之前Tarjan算法获取的强联通分量进行操作，迭代每个scc的每个node，去判断他们的prev是否在这个scc里，若不在，则返回这个node；即找到一个从外部跳转进来的块，那个块就是循环的入口。
   - 不可能超过1: 对于cminus来说，跳转指令只可能是if/else 和 while产生，不会有例如goto语句直接跳转到循环体内部。因此循环的入口只可能是while的条件块。
2. 简述一下算法怎么解决循环嵌套的情况。
   - 每次使用Tarjan算法后，只会获得大的循环体。在对其进`find_loop_base()`后，将base node加入reserved中，然后删除base node，（同时删除nodes,base后继的prev和前驱的succ中所有的basenode），这样做即将大的scc解体。
   - 接着对所有nodes中的结点初始化，然后回到while大循环，从头开始操作，直到所有的`result.size() == 0`即处理完所有嵌套。
   - 对reserved解释：因为之前删除了base后继的prev，若嵌套while紧随大的while，即这个入口的处于外层的prev刚好是被删除的base node，会出现所有的`find(prev)`都成功，则此时`base == nullptr`；去reserved中寻找，即大while的后继是否在这个scc中，若在，则代表是这个嵌套while的入口，返回即可。
### Mem2reg
1. 请简述支配边界的概念。
   - 某个结点n的支配边界包含，在离开n的每条CFG路线上，从n可达但不支配的第一个结点
   - 编译器通过支配边界(dominance_frontier)可以更加精确的判断何处需要phi结点
2. 请简述phi节点的概念，与其存在的意义。
   - 概念：在某些特定的基本块（程序的汇合点，具有多个前驱）的开始，为当前过程的每个定义或使用的每个名字插入的一个函数，用以合并不同边的值。对每个前驱块phi函数都要有个参数与之对应，phi函数的值是当前控制流经过的前驱块的参数。
   - 意义：对SSA来说，每个名字只会被赋值一次。若某BB有多个前驱块，且这些前驱块都对某个变量进行了赋值，此时并不知道程序会从哪个前驱块到达此BB，即接下来对这个变量使用的值是不确定的；使用phi函数就可以合并不同路径的参数，正确选择参数。
3. 请描述Mem2Reg Pass执行前后的ir的变化, 简述一下。
   - 简述：将所有store和load指令删除，并将所需要load的值重命名为对应的寄存器。同时增加了phi函数，以便汇总多个前驱块产生的不确定的值。
   - 事实上不会删除与全局变量和数组有关的store和load操作，因为这些是动态变化的。
4. 在放置phi节点的时候，算法是如何利用支配树的信息的？
   - 代码L65，此处意思是：在worklist里的每个BB的每个支配边界`bb_dominace_frontier_bb`的起始处放置phi节点，而此处就是利用了支配树的信息。
   - 如何计算支配边界需要用到支配树信息：即对每个汇合点j的前驱结点p，沿着支配树向上走，直到找到支配j的结点。
5. 算法是如何选择value(变量最新的值)来替换load指令的？（描述数据结构与维护方法）
   - 对每个`l_val`使用栈`var_val_stack`，遍历instr，若是load，用`l_val`栈顶的`val`去替换该`l_val`的`use_list`里所有存在。
   - 维护：
     - 遍历bb所有指令，若此处插入了`phi`，则吧`phi`的值入栈
     - 遍历bb所有指令，若指令为`store`，将其左值入栈
     - 深度搜索bb，继续`re_name`过程
     - 再次遍历所有指令，若是`phi`或`store`，则将栈顶元素弹出。

### 代码阅读总结

对SSA有了大体的了解，对课程内容也有了更好的掌握。

### 实验反馈 （可选 不会评分）

写完后面的再说

### 组间交流 （可选）

🈚️
